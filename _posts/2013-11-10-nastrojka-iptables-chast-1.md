---
title: Настройка iptables от простого к сложному. Часть 1.
date: 2013-11-10T20:49:28+03:00
author: Maxim Norin
layout: post
permalink: /nastrojka-iptables-chast-1.html
categories:
  - Статьи
tags:
  - iptables
  - боевой сервер
  - настройка
---
В Linux существует некоторое количество решений для настройки фаервола, однако многие из них являются на самом деле только фронтэндами для настройки iptables, и некоторые не совсем удачными. В принципе, неплохо, когда можно быстро настроить фаервол, но когда вы разберетесь с iptables, вы сможете это сделать быстрее и тоньше. Тонкая настройка iptables фронтэндам обычно недоступна.

Приступим. Начнем с простого, и потом будем усложнять конфигурацию. Здесь на сайте уже есть статья про автозагрузку правил iptables, поэтому мы не будем сейчас рассматривать загрузку правил, а сосредоточимся на самих правилах. Настраивается фаервол всегда под учетной записью root.
<!--more-->

## Сценарии сетевых подключений
Перед настройкой фаервола обязательно нужно иметь точное представление о том, какие сетевые соединения и как должны устанавливаться при работе системы, чтобы все сервисы могли нормально работать. Чем точнее у нас картина работы сетевых сервисов, как работающих на нашем сервере, так и на других серверах, тем более тонко можно настроить систему. Поэтому желательно всегда сначала описывать сценарии того, как всё должно работать, и только потом начинать настраивать фаервол. Сценарий можно написать в любом текстовом редакторе. Сначала описываем все внешние сервисы, с которыми работает сервер, а затем все сервисы, которые работают на сервере. Зачем это надо? Чтобы точно представлять сам процесс работы, без углубления в техническую часть. После написания максимально точного сценария можно приступать к настройке фаервола. Описание в сценарии должно выглядеть примерно так:

1) Все пользователи могут просматривать сайт. По умолчанию сайт на русском языке.
2) Если пользователи пришли с адресов <список-адресов-или-маска-подсети>, то им должен быть показан сайт на украинском. В нашем примере это будет, допустим, интернет-магазин с одним доменным именем, отображаемый на русском или украинском языке, и имеющий в продаже свой набор для России и Украины. У нас будет просто два сайта, один на русском, второй на украинском, и по адресу, с которого пришел клиент, будет определяться, на какой сайт он попадет. Пример взят из головы, на практике, конечно, такие вопросы решаются по другому. Можно также не разрешать просмотр сайта с китайских адресов из-за постоянного спама в комментариях на китайском.
3) Из офиса должна быть доступна почта, из других мест она не должна быть доступна.
4) Извне должна быть обеспечена возможность подключения к ВПН
5) Мы можем использовать только несколько DNS-серверов, которым мы доверяем. Все остальные сервера DNS должны быть недоступны
6) .....

И так далее. Думаю, достаточно для простого примера. Смысл в том, чтобы максимально точно определить картину сетевого взаимодествия. Любой сценарий имеет только одну цель - формализовать взаимодействие с пользователями и сервисами до составления описаний соединений, включающих порт, протокол, адрес источника, адрес назначения для каждого соединения.

## Настройка iptables: Самая простая конфигурация
Если говорить про боевые сервера, то настройка фаервола на двух серверах может сильно различаться, в зависимости от задач, которые выполняют эти сервера. Поэтому я постараюсь описать общие принципы, которыми можно пользоваться при настройке фаервола для любых серверов. Это только база для дальнейшей настройки.

В первую очередь, необходимо очистить загруженные правила:
```
iptables -F INPUT
iptables -F OUTPUT
iptables -F FORWARD
```
INPUT, OUTPUT, FORWARD - это три основные цепочки, по которым будут идти пакеты, входящие, исходящие и проходящие с интерфейса на интерфейс.

После этого необходимо задать политику по умолчанию. Их всего две - ACCEPT и DROP, принимать пакеты или не принимать. Для боевого сервера всегда необходимо выбирать DROP, а затем открывать всё, что необходимо и не более того.

Для задания таких политик необходимо предварительно разрешить соединения по SSH, будем считать, что мы не меняли стандартный порт (что обычно следует на боевых серверах делать сразу после установки SSH-сервера).
```
iptables -t filter -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT
```
И после этого уже можно приступать к изменению политик по умолчанию:
```
iptables -P INPUT DROP
iptables -P OUTPUT ACCEPT
iptables -P FORWARD DROP
```
Для цепочки OUTPUT пока можно оставить политику по умолчанию ACCEPT, разрешающую исходящие соединения, к ней можно переходить после настройки цепочки INPUT, когда мы запретим входящие соединения. На многих серверах достаточно бывает правильно настроить цепочку INPUT, но мы рассмотрим позже также и настройку OUTPUT для более жесткой конфигурации.

Итак. В данный момент у нас открыт только порт SSH-сервера для входящих соединений, на все остальные порты соединения проходить не будут. Теперь надо добавить прием соединений на порты остальных сервисов, если они на вашем сервере запущены.

SMTP:
```
iptables -t filter -A INPUT -p tcp -m tcp --dport 25 -j ACCEPT
```
DNS (обычно достаточно разрешить UDP, но можно также добавить и TCP):
```
iptables -t filter -A INPUT -p udp -m udp --dport 53 -j ACCEPT
```
HTTP:
```
iptables -t filter -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT
```
POP3:
```
iptables -t filter -A INPUT -p tcp -m tcp --dport 110 -j ACCEPT
```
HTTPS:
```
iptables -t filter -A INPUT -p tcp -m tcp --dport 443 -j ACCEPT
```
И так далее. Порты, которые необходимо открыть для того или иного сервиса, и протокол можно посмотреть в файле /etc/services, в котором перечислены все закрепленные за определенными сервисами порты.

Но это еще не всё. Порты открыты, сервисы доступны извне, но почта не работает и доменные имена не резолвятся. Дело в том, что при запросе DNS-серверов запрос отправляется с произвольного свободного порта из числа непривелегированных, точно так же, как и соединение с другим почтовым сервером. И ответ эти сервисы отправляют на тот же самый порт. А этот порт, как вы понимаете, у нас закрыт. Мы могли бы открыть этот порт, но мы не знаем, с какого порта будет исходящее соединение. Поэтому мы можем сделать самое простое, что может быть,- разрешить соединения с определенных портов удаленного компьютера:

SMTP:
```
iptables -t filter -A INPUT -p tcp -m tcp --sport 25 -j ACCEPT
```
DNS:
```
iptables -t filter -A INPUT -p udp -m udp --sport 53 -j ACCEPT
```
Эти два правила разрешают входящие соединения с портов 25/tcp и 53/udp, поэтому, когда с этих портов приходят пакеты по соответствующему протоколу, они будут приняты. Если вы планируете обновлять систему, программное обеспечение или устанавливать пакеты, необходимые для работы, то вам придется разрешить соединения с 80 порта удаленных машин.

Вот теперь самая простая конфигурация iptables у нас готова.

После внесения правил в таблицы, необходимо их сохранить. Для этого можно воспользоваться, например, <a title="Настройка автозагрузки правил iptables в Debian" href="/nastrojka-avtozagruzki-pravil-iptables-v-debian.html">таким</a> скриптом.

## Обработка источника соединения
Идем дальше. соединение по определенным портам нам необходимо не со всем Интернетом, а с определенными машинами, с определенными IP-адресами. Поэтому мы можем немного усложнить правила, добавив в них адрес источника пакетов.
```
iptables -t filter -A INPUT -s 123.123.123.123 -p tcp -m tcp --dport 22 -j ACCEPT
```
Данное правило позволяет принимать пакеты на 22 порт по протоколу TCP только из источника с адресом 123.123.123.123, на это указывает параметр "-s" (source, источник). Таким образом вы можете ограничить соединения с сервером по SSH одним определенным IP-адресом, либо определенной подсетью, если укажете маску подсети, из которой разрешены соединения вместо отдельного IP-адреса.

Если у вас всегда используется один и тот же почтовый шлюз, через который ваш сервер отправляет почту, то вы можете, например, ограничить соединения с порта 25/tcp, указав этот шлюз в качестве источника.

## Правила для конкретного сетевого интерфейса или IP-адреса
На сервере может быть несколько сетевых интерфейсов. Обычно их как минимум два - внешний сетевой и так называемый loopback-интерфейс 127.0.0.1, доступ к которому извне невозможен, если отсутствует соответствующее перенаправление пакетов. У вас также может как минимум еще один IP-адрес, используемый совместно с алиасом сетевого интерфейса, или еще один физический сетевой интерфейс. И на каждом IP-адресе или сетевом интерфейсе могут работать определенные сервисы. Например, на одном веб-сервер Apache, а на втором сервер службы доменных имен bind9. И когда вы разрешаете соединения на определенный порт без указания этого сетевого интерфейса, вы открываете доступ к этому порту на всех интерфейсах. Поэтому есть два способа сузить область действия разрешения.

Первый способ - указать IP-адрес, для которого будет разрешен доступ.
```
iptables -t filter -A INPUT -d 234.234.234.234 -p tcp -m tcp --dport 22 -j ACCEPT
```
Этот пример показывает, как можно использовать адрес назначения в правиле iptables. При этом также можно использовать адрес источника:
```
iptables -t filter -A INPUT -s 123.123.123.123 -d 234.234.234.234 -p tcp -m tcp --dport 22 -j ACCEPT
```
В данном пример мы уже ограничиваем доступ двумя адресами, что позволяет получить доступ по SSH к серверу по адресу 234.234.234.234 с адреса 123.123.123.123, с остальных адресов доступ вы получить не сможете.

Второй способ - указать имя сетевого интерфейса. Этот способ также применим, когда внешний адрес может измениться. В случае, если изменится адрес на сетевом интерфейсе, с предыдущим вариантом вы потеряете доступ к серверу. Указание имени интерфейса осуществляется следующим образом:
```
iptables -t filter -A INPUT -i eth0 -s 123.123.123.123 -p tcp -m tcp --dport 22 -j ACCEPT
```
Такой вариант разрешает доступ по SSH на сетевом интерфейсе eth0, на остальных сетевых интерфейсах доступ по SSH будет отсутствовать.

Всё, что мы только что рассмотрели - это только самое начало, в следующей части будет продолжение...
