---
title: Настройка iptables от простого к сложному. Часть 2.
date: 2013-11-16T17:50:13+03:00
author: Maxim Norin
layout: post
permalink: /nastrojka-iptables-chast-2.html
categories:
  - Статьи
tags:
  - firewall
  - iptables
  - linux
  - боевой сервер
  - настройка
  - фаервол
---
В [первой части](/nastrojka-iptables-chast-1.html) мы уже познакомились с самыми основами, давайте продолжим.

## Настройка iptables для состояний сетевого соединения
При фильтрации сетевых соединений также можно использовать текущий статус сетевых соединений. Давайте немного вспомним, как устанавливается сетевое подключение по протоколу TCP. Сначала инициатор соединения посылает SYN-пакет, сервер принимает его и посылает SYN- и ACK-пакеты, клиент отвечает ACK-пакетом, который принимает сервер, и только после этого соединение считается установленным, и начинается передача данных. Этот обмен пакетами называется хэндшейком или рукопожатием. Мы можем использовать статус сетевого соединения для обеспечения доступа. Например, открывать доступ к определенному порту, если мы с сервера иницировали подключение. В противном случае мы не будем открывать доступ на определенный порт. У сетевых соединений есть несколько статусов состояния, вот некоторые из них:
<!--more-->

NEW - установка нового соединения, первый пакет, который мы видим.

RELATED - соединение, связанное с другим, имеющим статус ESTABLISHED.

ESTABLISHED - установленное сетевое соединение.

INVALID - пакет не может быть идентифицирован как принадлежащий какому-то соединению.

UNTRACKED - пакеты, для которых ранее была применена цель NOTRACK. Мы пока применяли только цель ACCEPT, позже мы познакомимся и с другими. Для таких пакетов, например, не отслеживаются сопутствующие ICMP-пакеты.

Посылка пакета SYN на определенный порт говорит об установке соединения, если на определенный порт будет послан какой-то другой пакет, это не будет считаться новым соединением, посылка SYN на определенный порт соответствует состоянию NEW. После обмена SYN и ACK пакетами состояние соединения становится ESTABLISHED. Если установленное соединение приводит к открытию другого порта, то это обращение получает статус RELATED.

Очень простой пример - работа с FTP-сервером. Мы подключаемся к порту 21/tcp, в момент подключения соединение получается статус NEW, а затем ESTABLISHED. Управляющие команды идут через порт 21/tcp, но при работе для передачи файлов необходимо открыть еще и 20/tcp. И соединение на порт 20/tcp получает статус RELATED. Таким образом, доступ к порту 20/tcp можно закрывать до тех пор, пока соединение на него не придет со статусом RELATED, либо само соединение не получит статус ESTABLISHED. Получается, что для корректной фильтрации портов 21/tcp и 20/tcp мы можем сделать следующее:
```
iptables -t filter -A INPUT -p tcp -m tcp --dport 20 -m state --state RELATED,ESTABLISHED -j ACCEPT
iptables -t filter -A INPUT -p tcp -m tcp --dport 21 -m state --state NEW,ESTABLISHED -j ACCEPT
```
В этом случае без установки подключения на порт 21 мы не получим доступ к порту 20. Что необходимо знать для работы со статусами сетевых соединений? Надо представлять себе, как устанавливаются сетевые соединения и представлять, как работает с сетевыми соединениями сервис, для которого вы создаете правила фаервола.

## Настройка нескольких цепочек правил
До сих пор мы рассматривали только стандартные цепочки правил. iptables позволяет составлять собственные цепочки. Эта возможность позволяет увеличить гибкость обработки пакетов. Например, если у нас для определенной подсети должны быть установлены собственные правила, отличные от других подсетей, то мы можем создать определенную цепочку, в которую будем перенаправлять пакеты для последующей обработки. И в эту цепочку мы можем включать соответствующие разрешения. Это избавляет нас от необходимости добавлять источник пакетов в каждое правило, достаточно создать одно правило для конкретного источника, а затем перенаправить из него пакеты в отдельную цепочку, при этом основная настройка iptables сводится к созданию правила перенаправления в цепочку и создания и последующей оптимизации самой цепочки. Пакеты из остальных источников будут проходить так же, как и обычно. Это выглядит так: Сначала создаем новую цепочку:
```
iptables -N FIREWALL_CHAIN_1
```
Затем перенаправляем пакеты в эту цепочку:
```
iptables -t filter -A INPUT -s 192.168.0.0/24 -p tcp -m tcp -j FIREWALL_CHAIN_1
```
В параметре -j мы указываем название нашей цепочки правил, через которую будут перенаправляться пакеты. Раньше мы указывали там название стандартной цели - ACCEPT.
```
iptables -t filter -A FIREWALL_CHAIN_1 -p tcp -m tcp --dport 80 -j ACCEPT
```
Таким образом можно создать несколько цепочек, каждая из которых будет фильтровать пакеты независимо от других. Кроме того, можно точно так же перенаправлять пакеты из одной собственной цепочки в другую, выстраивая несколько цепочек в одну большую, либо разделяя поток пакетов на несколько. Таким образом вы можете детально разделить входящий поток на несколько на основании какого-либо признака, и при необходимости объединить их в один. Это позволяет оптимизировать обработку потока пакетов, пропуская обработку тех пакетов, для которых это не нужно, снизив тем самым нагрузку, что особенно актуально при большом трафике.

Продолжение следует...

Если у вас есть вопросы по какой-то определенной конфигурации, пишите, и мы рассмотрим ее в одной из следующих статей.
