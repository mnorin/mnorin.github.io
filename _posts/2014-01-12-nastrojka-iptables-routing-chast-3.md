---
title: Настройка iptables от простого к сложному. Часть 3.
date: 2014-01-12T11:55:52+03:00
author: Maxim Norin
layout: post
permalink: /nastrojka-iptables-routing-chast-3.html
categories:
  - Статьи
tags:
  - debian
  - firewall
  - iptables
  - linux
  - боевой сервер
  - настройка
  - фаервол
---
Давайте посмотрим, как работать с тем, что называют iptables routing, или перенаправлением пакетов при помощи iptables.
В [первой](/nastrojka-iptables-chast-1.html) и [второй](/nastrojka-iptables-chast-2.html) частях мы рассматривали настройку iptables, касающуюся блокировки пакетов, а теперь посмотрим, как не блокировать их, а направлять туда, куда нам нужно.
<!--more-->

## Маскарадинг (или маскирование)
Маскарадинг - это метод обработки пакетов, при котором пакеты передаются через некоторую машину, работающую как шлюз. Эта машина при пересылке пакетов помечает их, чтобы знать, какой машине в сети вернуть полученный ответ. Таким образом, несколько машин из внутренней сети могут обращаться к внешней сети, а извне это будет выглядеть так, как будто обращения идут от той самой машины, являющейся шлюзом. Маскарадинг связан в первую очередь с NAT (Network Address Translation), пакеты при трансляции адресов маскируются, чтобы ответ вернулся именно к источнику запроса.

Например, у нас есть некоторая локальная сеть с адресами 192.168.0.0/24, в этой сети есть шлюз с адресом 192.168.0.1, имеющий два сетевых интерфейса, eth0 и eth1. eth0 - внешний, подключенный к провайдеру, например, с адресом 192.168.100.25, eth1 - внутренний, подключенный к локальной сети, тот самый, на котором адрес 192.168.0.1. Необходимо обеспечить работу всех клиентов из локальной сети в сети Интернет таким образом, чтобы это было для них прозрачно.

В таком случае в первую очередь необходимо включить форвардинг пакетов между сетевыми интерфейсами шлюза, чтобы пропускать трафик из внутренней сети наружу. Есть два варианта, как это можно сделать. Первый - раскомментировать в файле /etc/sysctl.conf строчку
```
net.ipv4.ip_forward=1
```
После этого вам надо будет перезагрузиться, чтобы убедиться, что форвардинг работает. Второй - включить форвард вручную командой
```
echo "1" >/proc/sys/net/ipv4/ip_forward
```
Этот способ заработает без перезагрузки. Можно использовать оба, а можно в скрипте, например, использовать при загрузке правил iptables только второй.
После этого мы можем задать правило для адресной трансляции:
```
iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -d ! 192.168.0.0/24 -j MASQUERADE
```
Это правило после обработки пакетов осуществит маскирование, если пакеты из внутренней сети направлены куда-то в другую подсеть. Если нам нужно маскировать пакеты для конкретной подсети, к примеру, из одной локальной подсети (192.168.2.0/24) в другую (192.168.0.0/24), то мы можем создать следующее правило:
```
iptables -t nat -A POSTROUTING -s 192.168.2.0/24 -d 192.168.0.0/24 -j MASQUERADE
```

## Перенаправление пакетов на другой порт
Перенаправление портов можно использовать для самых разных задач. Например, перенаправление пользователей из разных сетей на разные экземпляры веб-сервера, перенаправление порта на другой, если изменился порт какого-то сервиса, настройка прозрачного проксирования и так далее. Общая идея в том, что пакеты с определенного порта перенаправляются на другой порт на том же сетевом интерфейсе той же самой машины, либо на loopback'е.

Для перенаправления порта, например, 80, с внешнего интерфейса на порт 80 на loopback-интерфейсе мы можем использовать правило
```
iptables -t nat -A PREROUTING -d 192.168.0.1/32 -p tcp -m tcp --dport 80 -j DNAT --to-destination 127.0.0.1:80
```
Это правило позволит перенаправить пакеты на loopback, изменив назначение пакета путем трансляции адреса (Destination NAT), и после этого можно будет их отфильтровать в цепочке, которая будет задана для loopback-интерфейса. Естественно, нужно будет сделать и обратную трансляцию:
```
iptables -t nat -A POSTROUTING -s 127.0.0.1/32 -p tcp -m tcp --dport 80 -j SNAT --to-source 192.168.0.1
```
Таким образом, происходит обратный процесс, при этом изменяется Source NAT, то есть, транслируется адрес источника соединения.

## Форвардинг портов на другую машину
По сути форвардинг портов на другую машину не отличается от форварда портов в пределах одной машины, но по существу это не одно и то же, поскольку пакеты будут передаваться не в пределах одной машины, как в случае с loopback-интерфейсом, когда фактически пакеты транслируются в пределах сетевого стека. Обычно форвардинг портов производится с определенного порта внешнего интерфейса на определенный порт машины во внутренней сети, поэтому между сетевыми интерфейсами должен быть настроен форвардинг. Например, проброс порта 3389 для работы удаленного рабочего стола (RDP) с внешнего сетевого интерфейса (192.168.100.25) на порт 3389 на одну из машин во внутренней сети (192.168.0.15):
```
iptables -t nat -A PREROUTING -d 192.168.100.25/32 -p tcp -m tcp --dport 3389 -j DNAT --to-destination 192.168.0.15:3389
iptables -t nat -A POSTROUTING -s 192.168.0.15/32 -p tcp -m tcp --dport 3389 -j SNAT --to-source 192.168.100.25
```

## Таблица форвардинга
При настройке iptables мы уже использовали таблицу форвардинга, но единственное, что мы делали - это очищали правила командой
```
iptables -F FORWARD
```
В этой таблице не рекомендуется фильтровать трафик, рекомендуется ее использовать только для перенаправления трафика. Фильтрацию необходимо выполнять либо до форвардинга, либо уже после. В таблице FORWARD вы определяете, куда должны форвардиться пакеты, а куда нет. Например:
- разрешить форвардинг между eth0 и eth1
- разрешить форвардинг между eth0 и eth2
- запретить форвардинг между eth1 и eth2

Правила в таком случае могут выглядеть так:
```
iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT
iptables -A FORWARD -i eth1 -o eth0 -j ACCEPT
iptables -A FORWARD -i eth0 -o eth2 -j ACCEPT
iptables -A FORWARD -i eth2 -o eth0 -j ACCEPT
iptables -A FORWARD -i eth1 -o eth2 -j DROP
iptables -A FORWARD -i eth2 -o eth1 -j DROP
```
либо еще короче:
```
iptables -A FORWARD -i eth1 -o eth2 -j DROP
iptables -A FORWARD -i eth2 -o eth1 -j DROP
```

## Разница между DROP и REJECT
При сбросе пакетов используют обычно две цели - DROP и REJECT, при этом нужно понимать, почему вы используете именно этот вариант. Основное различие состоит в том, что при использовании DROP не будет отправлен ICMP-ответ, по которому можно будет определить, что в соединении отказано. Оно просто не пройдет. Когда вы используете REJECT, то вы явно получите ответ, что в соединении отказано. Поэтому при составлении таблиц правил iptables лучше использовать REJECT, а когда вы окончательно определитесь с конфигурацией, можно изменить REJECT на DROP.
